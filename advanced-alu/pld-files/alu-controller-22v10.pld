GAL22V10
alucntrl

S0  S1      S2      S3      CRY     NC      NC      NC      NC      NC  NC  GND
NC  BITf    CMPf    Af      CMPi    ROTATE  ALUS0   ALUS1   ALUS2   AS0 AS1 VCC

; Pin Logic
;
;   when S3 == 0, it pertains to the ALU, and S3 == 1 is for the other functions.


; ALU instruction 
;   pretty straighforward here. Just a S0-S2 passthrough if S3 is low. 
;   Set the SUMf signal only for math operations.

ALUS0 = /S3 * S0        
ALUS1 = /S3 * S1
ALUS2 = /S3 * S2

; Register A / Shift Instructions
;
;                 S0 | S1 | S2 | S3     AS0 | AS1 | ROTATE | Af
;               +----+----+----+---- = -----+-----+--------+----
; Ai            |  1 |  1 |  0 |  1      1  |  1  |    0   |  0
; left shift    |  0 |  1 |  0 |  1      0  |  1  |    0   |  1
; left rotate   |  0 |  1 |  1 |  1      0  |  1  |    1   |  0
; right shift   |  1 |  0 |  0 |  1      1  |  0  |    0   |  1
; right rotate  |  1 |  0 |  1 |  1      1  |  0  |    1   |  0
; 
; 

AS0 =   S3 * /S2 * S1 * S0
      + S3 * /S1 * S0 

AS1 =   S3 * /S2 * S1 * S0
      + S3 * S1 * /S0

ROTATE =   S3 * S2 * /S1 * S0
         + S3 * S2 * S1 * /S0

Af =   AS0 * /AS1 * /ROTATE
     + AS1 * /AS0 * /ROTATE


; Comparison unit
;
;                  S0 | S1 | S2 | S3      CMPf   BITf    CMPi
;                 +----+----+----+---- = ------+------+-------
; compare values  |  1 |  1 |  1 |  1       1  |   0  |   1
; compare to zero |  0 |  0 |  1 |  1       1  |   0  |   0
; test bit        |  0 |  0 |  0 |  1       0  |   1  |   1
;

CMPf =   S3 * S2 * S1 * S0
       + S3 * S2 * /S1 * /S0
BITf =   S3 * /S2 * /S1 * /S0
CMPi =   S3 * S2 * S1 * S0
       + S3 * /S2 * /S1 * /S0


DESCRIPTION

Combinational logic for the ALU controller