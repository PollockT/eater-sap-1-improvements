GAL22V10
alucntrl

S0  S1      S2      S3      CRY     NC      NC      NC      NC      NC  NC  GND
NC  BITf    CMPf    SUMf    Af      ROTATE  ALUS0   ALUS1   ALUS2   AS0 AS1 VCC

; Pin Logic
;
;   when S3 == 0, it pertains to the ALU, and S3 == 1 is for the other functions.


; ALU instruction 
;   pretty straighforward here. Just a S0-S2 passthrough if S3 is low

ALUS0 = /S3 * S0        
ALUS1 = /S3 * S1
ALUS2 = /S3 * S2
SUMf = ALUS0 + ALUS1 + ALUS2

; Register A / Shift Instructions
;
;                 S0 | S1 | S2 | S3     AS0 | AS1 | ROTATE | Af
;               +----+----+----+---- = -----+-----+--------+----
; Ai            |  1 |  1 |  0 |  1      1  |  1  |    0   |  0
; left shift    |  0 |  1 |  0 |  1      0  |  1  |    0   |  1
; left rotate   |  0 |  1 |  1 |  1      0  |  1  |    1   |  0
; right shift   |  1 |  0 |  0 |  1      1  |  0  |    0   |  1
; right rotate  |  1 |  0 |  1 |  1      1  |  0  |    1   |  0
; 
; 


; AS0 = S3 * S0 * /(S0 * S1 * S2) ==> S0 only if not all S0-S2 active
AS0 =   S3 * S0 * /S1
      + S3 * S0 * /S2

; AS1 = S3 * S1 * /(S0 * S1 * S2) ==> S1 only if not all S0-S2 active
AS1 =   S3 * S1 * /S0
      + S3 * S1 * /S2

; ROTATE = S3 * S2 * ((S0 + S1) * /(S0 * S1)) ==> S2 only if one of S0 or S1 is active
ROTATE =   S3 * S2 * S0 * /S1
         + S3 * S2 * S1 * /S0

; Af = (AS0 + AS1) * /(AS0 * AS1) * /ROTATE ==> If only one of AS0 or AS1 active and not ROTATE
Af =   AS0 * /AS1 * /ROTATE
     + AS1 * /AS0 * /ROTATE


; Comparison unit
;
;                 S0 | S1 | S2 | S3      CMPf   BITf
;                +----+----+----+---- = ------+------
; comapre values |  1 |  1 |  1 |  1       1  |   0  
; test bit.      |  0 |  0 |  0 |  1       0  |   1  
;

CMPf = S3 * S0 * S1 * S2
BITf = S3 * /S0 * /S2 * /S2

DESCRIPTION

Combinational logic for the ALU controller